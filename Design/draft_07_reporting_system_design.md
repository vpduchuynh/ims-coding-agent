## 7. Reporting System Design

This section details the design of the reporting system for the PT-CLI, which leverages the external Quarto CLI tool (FR-RP-001) to generate comprehensive, publication-quality reports in various formats (PDF, HTML, Word) as required by FR-RP-004. The design focuses on the structure of the Quarto templates, the mechanism for passing data from the Python layer to Quarto, and the generation and integration of plots.

### 7.1 Default Quarto Template (`.qmd`) Structure and Content (FR-RP-007, FR-RP-009)

The PT-CLI will include at least one default Quarto Markdown (`.qmd`) template bundled with the application (FR-RP-007). This template will define the standard structure and content of the generated reports, ensuring all required information is presented clearly and professionally. Users can optionally provide their own custom `.qmd` template via configuration (FR-CM-003e, FR-RP-008).

**Template Structure:**

The default `.qmd` template will be structured logically, typically including:

1.  **YAML Header:** Contains Quarto configuration options, such as the report title, author (potentially configurable or set to "PT-CLI"), date, output format defaults (though usually overridden by CLI command), and potentially parameters for receiving data from the Python layer (if using the parameter passing method).
    ```yaml
    ---
    title: "Proficiency Testing Analysis Report"
    author: "PT-CLI Application"
    date: "today"
    format:
      pdf: default
      html: default
      docx: default
    params:
      results_file: "results.json" # Example if using intermediate file
      # OR define individual parameters if passing directly
      # x_pt: null 
      # u_x_pt: null
      # ... etc ...
    ---
    ```
2.  **Introduction/Summary Section:** Briefly describes the proficiency testing round or dataset being analyzed. Includes metadata like the date of analysis, input file used, and configuration settings applied. (FR-RP-009a)
3.  **Methodology Section:** Clearly states the method used for determining the assigned value (`x_pt`) (e.g., "Algorithm A (ISO 13528:2022, Annex C)", "CRM Based") and the method for calculating its uncertainty (`u(x_pt)`). Mentions the standard deviation for proficiency assessment (`σ_pt`) used. (FR-RP-009b)
4.  **Results Section:** Presents the key numerical results:
    *   The calculated assigned value (`x_pt`). (FR-RP-009c)
    *   The standard uncertainty of the assigned value (`u(x_pt)`). (FR-RP-009c)
    *   The robust standard deviation (`s*`) if Algorithm A or similar was used. (FR-RP-009d)
    *   The number of participants included in the final calculation (`p`). (FR-RP-009e)
5.  **Data Visualization Section:** Includes relevant plots generated by the Python layer (or dynamically via code chunks). Examples include:
    *   Histogram or Kernel Density Estimate (KDE) plot of participant results. (FR-RP-009g)
    *   Potentially a plot showing participant results relative to `x_pt` and performance limits (derived from `σ_pt`).
6.  **Participant Performance Section:** Lists or summarizes participant performance scores (z-scores and/or z		-scores). This might be a table showing Participant ID and corresponding score(s). (FR-RP-009f)
7.  **Appendix/Configuration Details (Optional):** Could include a more detailed dump of the configuration parameters used for the run.

**Content Generation:**
The `.qmd` file will contain Markdown text combined with placeholders or code chunks to dynamically insert the data passed from the Python layer. If using an intermediate JSON file (`results.json`), the template might use Python or R code chunks (Quarto supports multiple engines) to read this file and access its contents. Example using a Python chunk:

```qmd
```{{python}}
import json

# Assuming 'params.results_file' is defined in YAML header
with open(params.results_file, 'r') as f:
  results = json.load(f)

x_pt = results['calculation']['x_pt']
u_x_pt = results['calculation']['u_x_pt']
# ... load other values ...
```

Assigned Value (`x_pt`): **`{{python}} f"{x_pt:.4f}"`**

Standard Uncertainty (`u(x_pt)`): **`{{python}} f"{u_x_pt:.4f}"`**

```
Alternatively, if passing parameters directly, they can be accessed via `params.<param_name>`.

### 7.2 Data Preparation and Passing Mechanism (Python to Quarto) (FR-RP-002, FR-RP-003)

The Python layer (`reporting.py`) is responsible for preparing all necessary data calculated by the Rust engine and gathered from configuration/input, and passing it effectively to the Quarto rendering process (FR-RP-002).

**Data Preparation:**
Before invoking Quarto, `reporting.py` will aggregate all required information into a structured format. A Python dictionary is suitable for this, containing keys that align with the expected structure in the `.qmd` template (e.g., `calculation_results`, `config_summary`, `participant_scores`, `plot_paths`).

**Passing Mechanism (FR-RP-003):**
The primary mechanism for passing this structured data to Quarto will be via an **intermediate JSON file**. This approach is robust for complex data structures and avoids potential command-line length limitations.

1.  **Serialization:** The aggregated Python dictionary containing all results, configuration details, plot file paths, and potentially summarized participant data/scores will be serialized to a JSON file (e.g., `_temp_results.json`) in a temporary or output directory.
2.  **Quarto Invocation:** The `subprocess` call to Quarto in `reporting.py` will include an argument to pass the path to this JSON file. This can be done using Quarto's parameter passing mechanism, often via `--metadata-file` or by defining a parameter in the YAML header (`params: results_file: path/to/file.json`) and passing the actual path via `-P results_file:actual/path/to/file.json`.
    ```python
    # Example in reporting.py
    import json
    import subprocess
    from pathlib import Path

    def _write_quarto_data_json(data: dict, path: Path):
        with open(path, 'w') as f:
            json.dump(data, f, indent=2)

    def _invoke_quarto(template_path: Path, output_path: Path, data_path: Path, format: str):
        cmd = [
            "quarto", "render", str(template_path),
            "--output", str(output_path), 
            "--to", format,
            "-P", f"results_file:{data_path}" # Pass data file path as parameter
        ]
        try:
            # Use check=True to raise CalledProcessError on failure
            subprocess.run(cmd, check=True, capture_output=True, text=True)
        except FileNotFoundError:
            # Handle case where Quarto CLI is not found
            raise RuntimeError("Quarto CLI not found. Please ensure it is installed and in PATH.")
        except subprocess.CalledProcessError as e:
            # Handle Quarto rendering errors
            raise RuntimeError(f"Quarto rendering failed:\nSTDOUT:\n{e.stdout}\nSTDERR:\n{e.stderr}")

    # In generate_report function:
    # ... aggregate data_dict ...
    temp_data_path = Path("_temp_results.json") # Use tempfile module for better practice
    _write_quarto_data_json(data_dict, temp_data_path)
    _invoke_quarto(template_path, output_path, temp_data_path, output_format)
    # ... clean up temp_data_path ...
    ```
3.  **Quarto Consumption:** The `.qmd` template reads this JSON file (as shown in 7.1) to access the data needed for rendering the report.

This intermediate file approach provides a clean separation between Python data preparation and Quarto rendering.

### 7.3 Plot Generation and Integration (Matplotlib/Seaborn) (FR-RP-005)

The Python layer (`reporting.py`) will use libraries like `matplotlib` and `seaborn` to generate visualizations as required by FR-RP-009g.

**Generation:**
Functions within `reporting.py` will take the relevant data (e.g., participant results arrays) and generate plots like histograms or KDE plots.

**Integration:**
The primary method for integrating these plots into the Quarto report will be by **saving them as static image files** (e.g., PNG).

1.  **Save Plots:** After generating a plot using Matplotlib/Seaborn, `reporting.py` will save it to a file (e.g., `_temp_histogram.png`) in a known location (e.g., the same temporary directory as the JSON data file).
    ```python
    # Example in reporting.py
    import matplotlib.pyplot as plt
    import seaborn as sns

    def _generate_histogram(data, output_path: Path):
        plt.figure()
        sns.histplot(data, kde=True)
        plt.title("Distribution of Participant Results")
        plt.xlabel("Result")
        plt.ylabel("Frequency")
        plt.savefig(output_path)
        plt.close() # Close plot to free memory

    # In generate_report function:
    # ...
    plot_path = Path("_temp_histogram.png")
    _generate_histogram(participant_results_array, plot_path)
    # Add plot_path to the data_dict passed to Quarto
    data_dict['plot_paths']['histogram'] = str(plot_path.resolve())
    # ...
    ```
2.  **Include in Quarto:** The `.qmd` template will include the generated image using standard Markdown syntax, referencing the path passed from Python (e.g., via the JSON file).
    ```qmd
    ### Data Distribution

    ```{{python}}
    # Assuming results loaded from JSON into 'results' dict
    hist_path = results['plot_paths']['histogram']
    ```

    ![
    Distribution of Participant Results
    ]({{{{python}} hist_path}})
    ```

This approach keeps the plotting logic within Python and uses Quarto primarily for document assembly. While Quarto *can* execute Python code chunks to generate plots dynamically, saving static images is often simpler and avoids potential environment conflicts between the main application's Python environment and Quarto's execution environment.

This reporting system design ensures that all required information and visualizations are included in the final report, leveraging the strengths of Python for data processing/plotting and Quarto for high-quality document generation.
